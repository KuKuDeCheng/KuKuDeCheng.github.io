---
title: MySQL事务实现原理
date: 2023-07-27
category: 面试
---

关键词： `ACID` `UNDO_LOG` `Buffer Pool 缓冲区` `REDO_LOG` `MVCC` `脏读和不可重复读`  `行锁表锁`  `幻读` 

https://zhuanlan.zhihu.com/p/117452178

## 答
Mysql 里面的事务，满足 `ACID` 特性，所以在我看来，Mysql 的事务实现原理， 就是 InnoDB 是如何保证 ACID 特性的。 

首先，A 表示 Atomic 原子性，也就是需要保证多个 DML 操作是原子的，要么都 成功，要么都失败。 那么，失败就意味着要对原本执行成功的数据进行回滚，所以 InnoDB 设计了一 个 UNDO_LOG 表，在事务执行的过程中，把修改之前的数据快照保存到 `UNDO_LOG` 里面，一旦出现错误，就直接从 UNDO_LOG 里面读取数据执行反 向操作就行了。 

其次，C 表示一致性，表示数据的完整性约束没有被破坏，这个更多是依赖于业 务层面的保证，数据库本身也提供了一些，比如主键的唯一余数，字段长度和类 型的保证等等。 

接着，I 表示事物的隔离性，也就是多个并行事务对同一个数据进行操作的时候， 如何避免多个事务的干扰导致数据混乱的问题。 而 InnoDB 实现了 SQL92 的标准，提供了四种隔离级别的实现。分别是： `RU（未提交读） RC（已提交读） RR（可重复读）Serializable（串行化） `

InnoDB 默认的隔离级别是 RR（可重复读），然后使用了 `MVCC` 机制解决了脏读和不可重复读的问题，然后使用了`行锁/表锁`的方式解决了幻读的问题。 

最后一个是 D，表示持久性，也就是只要事务提交成功，那对于这个数据的结果 的影响一定是永久性的。 不能因为宕机或者其他原因导致数据变更失效。 

理论上来说，事务提交之后直接把数据持久化到磁盘就行了，但是因为随机磁盘 IO 的效率确实很低，所以 InnoDB 设计了 `Buffer Pool 缓冲区`来优化，也就是数 据发生变更的时候先更新内存缓冲区，然后在合适的时机再持久化到磁盘。 那在持久化这个过程中，如果数据库宕机，就会导致数据丢失，也就无法满足持 久性了。 所以 InnoDB 引入了 Redo_LOG 文件，这个文件存储了数据被修改之后的值， 当我们通过事务对数据进行变更操作的时候，除了修改内存缓冲区里面的数据以 外，还会把本次修改的值追加到 REDO_LOG 里面。 当提交事务的时候，直接把 REDO_LOG 日志刷到磁盘上持久化，一旦数据库出 现宕机，在 Mysql 重启在以后可以直接用 REDO_LOG 里面保存的重写日志读 取出来，再执行一遍从而保证持久性。 

因此，在我看来，事务的实现原理的核心本质就是如何满足 ACID 的，在 InnDB 里面用到了 MVCC、行锁表锁、UNDO_LOG、REDO_LOG 等机制来保证。 以上就是我对这个问题的理解！ 

## 面试点评 

InnDB 的事务实现原理，有很多可以借鉴的设计思想， 比如`乐观锁`、利用内存缓冲区的方式，以空间换时间的思想优化磁盘 IO 的性能 等等这些思想还挺重要的，比如在分布式事务框架 Seata 的 AT 模式的数据回滚，就 借鉴了 InnDB 里面 UNDO_LOG 的设计思想。


## MVCC基础

MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。

InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，当然存储的并不是实际的时间值，而是系统版本号。以上片段摘自《高性能Mysql》这本书对MVCC的定义。`他的主要实现思想是通过数据多版本来做到读写分离。从而实现不加锁读进而做到读写并行。`

MVCC在mysql中的实现依赖的是undo log与read view：

- undo log :undo log 中记录某行数据的多个版本的数据。
- read view :用来判断当前版本数据的可见性。

基本特征

1. 每行数据都存在一个版本，每次数据更新时都更新该版本。
2. 修改时Copy出当前版本随意修改，各个事务之间无干扰。
3. 保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）。

补充

1. MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）；
2. Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC；原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。
3. 串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题；
4. 通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。

## 事务的实现

前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。

- 事务的原子性是通过 undo log 来实现的
- 事务的持久性性是通过 redo log 来实现的
- 事务的隔离性是通过 (读写锁+MVCC)来实现的
- 而事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的。

原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！

总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。

## 原子性的实现

## 持久性的实现

## 隔离性实现

隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。

越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。

Mysql 隔离级别有以下四种（级别由低到高）：

- READ UNCOMMITED (未提交读)
- READ COMMITED (提交读)
- REPEATABLE READ (可重复读)
- SERIALIZABLE (串行化)

只要彻底理解了隔离级别以及他的实现原理就相当于理解了ACID里的隔离型。前面说过原子性，隔离性，持久性的目的都是为了要做到一致性，但隔离型跟其他两个有所区别，原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。

那么隔离性是要做到什么呢？`隔离性是要管理多个并发读写请求的访问顺序`。 这种顺序包括串行或者是并行。

说明一点，写请求不仅仅是指insert操作，又包括update操作。

总之，从隔离性的实现可以看出这是一场数据的可靠性与性能之间的权衡。

可靠性性高的，并发性能低(比如 Serializable)；

可靠性低的，并发性能高(比如 Read Uncommited)。

### READ UNCOMMITTED

在READ UNCOMMITTED隔离级别下，事务中的修改即使还没提交，对其他事务是可见的。事务可以读取未提交的数据，造成脏读。

因为读不会加任何锁，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到读写并行。

优点：读写并行，性能高。

缺点：造成`脏读`。

### READ COMMITTED

一个事务的修改在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。在很多场景下这种逻辑是可以接受的。

InnoDB在 READ COMMITTED，使用`排它锁`, `读取数据不加锁而是使用了MVCC机制`。或者换句话说他采用了`读写分离机制`。

但是该级别会产生`不可重读以及幻读`问题。

什么是不可重读？在一个事务内多次读取的结果不一样。

为什么会产生不可重复读？这跟 READ COMMITTED 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新生成一个版本号，所以每次select的时候读的不是一个副本而是不同的副本。

在每次select之间有其他事务更新了我们读取的数据并提交了，那就出现了不可重复读：

### REPEATABLE READ(Mysql默认隔离级别)

在一个事务内的多次读取的结果是一样的。这种级别下可以避免，脏读，不可重复读等查询问题。mysql 有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及MVCC。

采用读写锁实现：

为什么能可重复度？只要没释放读锁，在次读的时候还是可以读到第一次读的数据。

优点：实现起来简单。

缺点：无法做到读写并行。

采用MVCC实现：

为什么能可重复度？因为多次读取只生成一个版本，读到的自然是相同数据。

优点：读写并行 。

缺点：实现的复杂度高。

但是在该隔离级别下仍会存在幻读的问题，关于幻读的解决我打算另开一篇来介绍。



### SERIALIZABLE

该隔离级别理解起来最简单，实现也最单。在隔离级别下除了不会造成数据不一致问题，没其他优点。

## 幻读被完全解决了吗？

https://zhuanlan.zhihu.com/p/564735312


