---
title: Mysql为什么使用B+Tree作为索引结构
date: 2023-07-27
category: 面试
---

关于这个问题，我从几个方面来回答。 

首先，常规的数据库存储引擎，一般都是采用 B 树或者 B+树来实现索引的存储。 

因为 B 树是一种`多路平衡树`，用这种存储结构来存储大量数据，它的整个高度 会相比二叉树来说，会矮很多。 而对于数据库来说，所有的数据必然都是存储在磁盘上的，而磁盘 IO 的效率实 际上是很低的，特别是在随机磁盘 IO 的情况下效率更低。

所以树的高度能够决定磁盘 IO 的次数，磁盘 IO 次数越少，对于性能的提升就 越大，这也是为什么采用 B 树作为索引存储结构的原因。

但是在 Mysql 的 InnoDB 存储引擎里面，它用了一种增强的 B 树结构，也就是 B+树来作为索引和数据的存储结构

相比较于 B 树结构，B+树做了几个方面的优化。 

- `B+树的所有数据都存储在叶子节点，非叶子节点只存储索引`。
- `叶子节点中的数据使用双向链表的方式进行关联。`

使用 B+树来实现索引的原因，我认为有几个方面。 

- B+树非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味着 B+树在层高相同的情况下存储的数据量要比 B 树要多，使得磁盘 IO 次数更少。 

- 在 Mysql 里面，范围查询是一个比较常用的操作，而 B+树的所有存储在叶子节 点的数据使用了`双向链表`来关联，所以在查询的时候只需查两个节点进行遍历就 行，而 B 树需要获取所有节点，所以 B+树在范围查询上效率更高。 

- 在数据检索方面，由于所有的数据都存储在叶子节点，所以 B+树的 IO 次数会更 加稳定一些。 

- 因为叶子节点存储所有数据，所以 B+树的全局扫描能力更强一些，因为它只需 要扫描叶子节点。但是 B 树需要遍历整个树。 

- 另外，基于 B+树这样一种结构，如果采用自增的整型数据作为主键，还能更好 的避免增加数据的时候，带来叶子节点分裂导致的大量运算的问题。 

- 总的来说，我认为技术方案的选型，更多的是去解决当前场景下的特定问题，并 不一定是说 B+树就是最好的选择，就像 MongoDB 里面采用 B 树结构，本质上 来说，其实是关系型数据库和非关系型数据库的差异。 以上就是我对这个问题的理解

## b 树和 b+树的理解

为了更清晰的解答这个问题，我打算从三个方面来回答： 了解`二叉树`、`AVL 树`、`B 树`的概念 B 树和 B+树的应用场景 B 树是一种多路平衡查找树，为了更形象的理解。 

`二叉树`，每个节点支持两个分支的树结构，相比于单向链表，多了一个分支。 

`二叉查找树`，在二叉树的基础上增加了一个规则，左子树的所有节点的值都小于 它的根节点，右子树的所有子节点都大于它的根节点。，

二叉查找树会出现斜树问题，导致时间复杂度增加，因此又引入了一种`平衡二叉树`，它具有二叉查找树的所有特点，同时增加了一个规则：”它的左右两个子 树的高度差的绝对值不超过 1“。平衡二叉树会采用左旋、右旋的方式来实现平 衡。

而` B 树`是一种`多路平衡查找树`，它满足平衡二叉树的规则，但是它可以有多个子树，子树的数量取决于关键字的数量，比如这个图中根节点有两个关键字 3 和 5，那么它能够拥有的子路数量=关键字数+1。因此从这个特征来看，在存储同样数据量的情况下，平衡二叉树的高度要大于 B 树

`B+树`，其实是在 B 树的基础上做的增强，最大的区别有两个： B 树的数据存储在每个节点上，而 B+树中的数据是存储在叶子节点，并且通过 链表的方式把叶子节点中的数据进行连接。 
B+树的子路数量等于关键字数 这个是 B 树的存储结构，从 B 树上可以看到每个节点会存储数据。

B 树和 B+树，一般都是应用在文件系统和数据库系统中，用来减少磁盘 IO 带来 的性能损耗

以 Mysql 中的 InnoDB 为例，当我们通过 select 语句去查询一条数据时，InnoDB 需要从磁盘上去读取数据，这个过程会涉及到磁盘 IO 以及磁盘的随机 IO 我们知道磁盘 IO 的性能是特别低的，特别是随机磁盘 IO。

因为，磁盘 IO 的工作原理是，首先系统会把数据逻辑地址传给磁盘，磁盘控制 电路按照寻址逻辑把逻辑地址翻译成物理地址，也就是确定要读取的数据在哪个 磁道，哪个扇区。 为了读取这个扇区的数据，需要把磁头放在这个扇区的上面，为了实现这一个点， 磁盘会不断旋转，把目标扇区旋转到磁头下面，使得磁头找到对应的磁道，这里 涉及到寻道事件以及旋转时间。

因为，磁盘 IO 的工作原理是，首先系统会把数据逻辑地址传给磁盘，磁盘控制 电路按照寻址逻辑把逻辑地址翻译成物理地址，也就是确定要读取的数据在哪个 磁道，哪个扇区。 为了读取这个扇区的数据，需要把磁头放在这个扇区的上面，为了实现这一个点， 磁盘会不断旋转，把目标扇区旋转到磁头下面，使得磁头找到对应的磁道，这里 涉及到寻道事件以及旋转时间。

很明显，磁盘 IO 这个过程的性能开销是非常大的，特别是查询的数据量比较多 的情况下。 所以在 InnoDB 中，干脆对存储在磁盘块上的数据建立一个索引，然后把索引数 据以及索引列对应的磁盘地址，以 B+树的方式来存储。

如图所示，当我们需要查询目标数据的时候，根据索引从 B+树中查找目标数据 即可，由于 B+树分路较多，所以只需要较少次数的磁盘 IO 就能查找到。

数据结构在实际开发中非常常见，比如数组、链表、双向链表、红黑树、跳跃表、 B 树、B+树、队列等。 在我看来，数据结构是编程中最重要的基本功之一。 学了顺序表和链表，我们就能知道查询操作比较多的场景中应该用顺序表，修改 操作比较多的场景应该使用链表。 学了队列之后，就知道对于 FIFO 的场景中，应该使用队列。 学了树的结构后，会发现原来查找类的场景，还可以更进一步提升查询性能。 基本功决定大家在技术这个岗位上能够走到的高度。



