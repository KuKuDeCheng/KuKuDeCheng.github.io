---
title: DCL 单例模式设计为什么需要 volatile 修饰实例对象
date: 2023-07-27
category: 面试
---


我所理解的 DCL 问题，是在基于双重检查锁设计下的单例模式中，存在不完整 对象的问题。 

而这个不完整对象的本质，是因为`指令重排序`导致的。

当我们使用 instance=new DCLExample()构建一个实例对象的时候，因为 new 这个 操作并不是原子的。 所以这段代码最终会被编译成 3 条指令。 

为对象分配内存空间 

初始化对象 

把实例对象赋值给 instance 引用

由于这是三个指令并不是原子的。 按照重排序规则，在不影响单线程执行结果的情况下，两个不存在依赖关系的指 令允许重排序，也就是不一定会按照代码编写顺序来执行。

这样一来就会导致其他线程可能拿到一个不完整的对象，也就是这个 instance 已经分配了引用实例，但是这个实例的初始化指令还没执行。解决办法就是可以在 instance 这个变量上增加一个 volatile 关键字修饰， volatile 底层使用了内存屏障机制来避免指令重排序
