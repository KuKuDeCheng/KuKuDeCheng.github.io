---
title: ReentrantLock 是如何实现锁公平和非 公平性的
date: 2023-07-27
category: 面试
---

我先解释一下个公平和非公平的概念。 

公平，指的是竞争锁资源的线程，严格按照请求顺序来分配锁。 

非公平，表示竞争锁资源的线程，允许插队来抢占锁资源。 

ReentrantLock 默认采用了非公平锁的策略来实现锁的竞争逻辑。

其次，ReentrantLock 内部使用了 AQS 来实现锁资源的竞争，没有竞争到锁资源的线程，会加入到 AQS 的同步队列里面，这个队列是一个 FIFO 的双向链表。

在这样的一个背景下，公平锁的实现方式就是，线程在竞争锁资源的时候判断 AQS 同步队列里面有没有等待的线程。 如果有，就加入到队列的尾部等待。

而非公平锁的实现方式，就是不管队列里面有没有线程等待，它都会先去尝试抢 占锁资源，如果抢不到，再加入到 AQS 同步队列等待。

## 为什么默认非公平呢

ReentrantLock 和 Synchronized 默认都是非公平锁的策略，之所以要这么设计， 我认为还是考虑到了性能这个方面的原因。

因为一个竞争锁的线程如果按照公平的策略去阻塞等待，同时 AQS 再把等待队 列里面的线程唤醒，这里会涉及到内核态的切换，对性能的影响比较大

如果是非公平策略，当前线程正好在上一个线程释放锁的临界点抢占到了锁，就 意味着这个线程不需要切换到内核态，虽然对原本应该要被唤醒的线程不公平， 但是提升了锁竞争的性能。