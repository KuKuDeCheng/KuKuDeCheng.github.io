---
title: 谈一下 CAS 机制
date: 2023-07-27
category: 面试
---

CAS 是 Java 中 Unsafe 类里面的方法，它的全称是 CompareAndSwap，比较 并交换的意思。它的主要功能是能够保证在多线程环境下，对于共享变量的修改 的原子性。

我来举个例子，比如说有这样一个场景，有一个成员变量 state，默认值是 0，

定义了一个方法 doSomething()，这个方法的逻辑是，判断 state 是否为 0，如果 为 0，就修改成 1。

这个逻辑看起来没有任何问题，但是在多线程环境下，会存在原子性的问题，因 为这里是一个典型的，Read-Write 的操作

一般情况下，我们会在 doSomething()这个方法上加同步锁来解决原子性问题。

但是，加同步锁，会带来性能上的损耗，所以，对于这类场景，我们就可以使用 CAS 机制来进行优化

在 doSomething()方法中，我们调用了 unsafe 类中的 compareAndSwapInt()方 法来达到同样的目的，这个方法有四个参数，

分别是：`当前对象实例`、`成员变量 state 在内存地址中的偏移量`、`预期值 0`、`期 望更改之后的值 1`。

CAS 机制会比较 state 内存地址偏移量对应的值和传入的预期值 0 是否相等，如 果相等，就直接修改内存地址中 state 的值为 1

否则，返回 false，表示修改失败，而这个过程是原子的，不会存在线程安全问 题



CompareAndSwap 是一个 native 方法，实际上它最终还是会面临同样的问题， 就是先从内存地址中读取 state 的值，然后去比较，最后再修改。

这个过程不管是在什么层面上实现，都会存在原子性问题。

所以呢，CompareAndSwap 的底层实现中，在`多核 CPU 环境`下，会增加一个 `Lock 指令对缓存或者总线加锁`，从而保证`比较并替换`这`两个指令的原子性`。

CAS 主要用在并发场景中，比较典型的使用场景有两个。

第一个是 J.U.C 里面 Atomic 的原子实现，比如 AtomicInteger，AtomicLong。

第 二 个 是 实 现 多 线 程 对 共 享 资 源 竞 争 的 互 斥 性 质 ， 比 如 在 AQS 、 ConcurrentHashMap、ConcurrentLinkedQueue 等都有用到。