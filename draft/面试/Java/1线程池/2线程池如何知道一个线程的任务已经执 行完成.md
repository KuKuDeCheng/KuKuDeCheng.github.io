---
title: 线程池如何知道一个线程的任务已经执行完成
date: 2023-07-27
category: 面试
---

好的，我会从两个方面来回答。 在线程池内部，当我们把一个任务丢给线程池去执行，线程池会调度工作线程来 执行这个任务的 run 方法，run 方法正常结束，也就意味着任务完成了。

所以线程池中的工作线程是通过同步调用任务的 run()方法并且等待 run 方法返 回后，再去统计任务的完成数量。

如果想在线程池外部去获得线程池内部任务的执行状态，有几种方法可以实现。

线程池提供了一个 isTerminated()方法，可以判断线程池的运行状态，我们可以循 环判断 isTerminated()方法的返回结果来了解线程池的运行状态，一旦线程池的运 行状态是 Terminated，意味着线程池中的所有任务都已经执行完了。想要通过这 个方法获取状态的前提是，程序中主动调用了线程池的 shutdown()方法。在实际 业务中，一般不会主动去关闭线程池，因此这个方法在实用性和灵活性方面都不 是很好。

在线程池中，有一个 submit()方法，它提供了一个 Future 的返回值，我们通过 Future.get()方法来获得任务的执行结果，当线程池中的任务没执行完之前， future.get()方法会一直阻塞，直到任务执行结束。因此，只要 future.get()方法正常 返回，也就意味着传入到线程池中的任务已经执行完成了！

可以引入一个 CountDownLatch 计数器，它可以通过初始化指定一个计数器进 行倒计时，其中有两个方法分别是 await()阻塞线程，以及 countDown()进行倒计 时，一旦倒计时归零，所以被阻塞在 await()方法的线程都会被释放。 基于这样的原理，我们可以定义一个 CountDownLatch 对象并且计数器为 1，接 着在线程池代码块后面调用 await()方法阻塞主线程，然后，当传入到线程池中的 任务执行完成后，调用 countDown()方法表示任务执行结束。

最后，计数器归零 0，唤醒阻塞在 await()方法的线程。

基于这个问题，我简单总结一下，不管是线程池内部还是外部，要想知道线程是 否执行结束，我们必须要获取线程执行结束后的状态，而线程本身没有返回值， 所以只能通过`阻塞-唤醒`的方式来实现，future.get 和 CountDownLatch 都是这样 一个原理。

