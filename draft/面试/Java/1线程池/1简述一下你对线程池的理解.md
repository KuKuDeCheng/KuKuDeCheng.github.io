---
title: 简述一下你对线程池的理解
date: 2023-07-27
category: 面试
---

关键字：`池化技术` `线程复用` `生产者消费者`

关于这个问题，我会从几个方面来回答。 

首先，线程池本质上是一种`池化技术`，而池化技术是一种`资源复用`的思想，比较 常见的有连接池、内存池、对象池。 

而线程池里面复用的是`线程资源`，它的核心设计目标，我认为有两个： 

`减少线程的频繁创建和销毁带来的性能开销`，因为线程创建会涉及到 CPU 上下 文切换、内存分配等工作。 线程池本身会有参数来控制线程创建的数量，这样就可以避免无休止的创建线程 带来的资源利用率过高的问题，起到了资源保护的作用。 

其次，我简单说一下线程池里面的`线程复用技术`。因为线程本身并不是一个受控 的技术，也就是说`线程的生命周期时由任务运行的状态决定的，无法人为控制`。 所以为了实现线程的复用，线程池里面用到了`阻塞队列`，简单来说就是线程池里 面的`工作线程处于一直运行状态`，它会`从阻塞队列中去获取待执行的任务`，一旦 队列空了，那这个工作线程就会被阻塞，直到下次有新的任务进来。 也就是说，工作线程是根据任务的情况实现阻塞和唤醒，从而达到线程复用的目 的。

最后，线程池里面的资源限制，是通过几个关键参数来控制的，分别是`核心线程 数`、`最大线程数`。 核心线程数表示默认长期存在的工作线程，而最大线程数是根据任务的情况动态 创建的线程，主要是提高阻塞队列中任务的

## 线程池是如何实现线程复用的

线程池里面采用了`生产者消费者`的模式，来实现线程复用。 

生产者消费者模型，其实就是通过一个中间容器来解耦生产者和消费者的任务处 理过程。 生产者不断生产任务保存到容器，消费者不断从容器中消费任务。 

在线程池里面，因为需要保证`工作线程`的重复使用，并且这些线程应该是有任务 的时候执行，没任务的时候等待并释放 CPU 资源。 因此它使用了`阻塞队列`来实现这样一个需求。 提交任务到线程池里面的线程称为生产者线程，它不断往线程池里面传递任务。 这些任务会保存到线程池的阻塞队列里面。 然后线程池里面的工作线程不断从阻塞队列获取任务去执行。

基于阻塞队列的特性，使得阻塞队列中如果没有任务的时候，这些工作线程就会 阻塞等待。 直到又有新的任务进来，这些工作线程再次被唤醒。 从而达到线程复用的目的，以上就是我对这个问题的理解！

## 线程池的线程回收

`核心线程 数`、`最大线程数`

首先，线程池里面分为`核心线程和非核心线程`。 核心线程是常驻在线程池里面的工作线程，它有两种方式初始化。 

向线程池里面添加任务的时候，被动初始化主动调用 prestartAllCoreThreads 方法, 当线程池里面的队列满了的情况下，为了增加线程池的任务处理能力。 线程池会增加非核心线程。 核心线程和非核心线程的数量，是在构造线程池的时候设置的，也可以动态进行 更改.

由于`非核心线程`是为了解决任务过多的时候临时增加的，所以当`任务处理完成`后， 工作线程处于空闲状态的时候，就`需要回收`

因为所有工作线程都是从阻塞队列中去获取要执行的任务，所以只要在一定时间 内，阻塞队列没有任何可以处理的任务，那这个线程就可以结束了。 这个功能是通过阻塞队列里面的 poll 方法来完成的。这个方法提供了超时时间和 超时时间单位这两个参数当超过指定时间没有获取到任务的时候，poll 方法返回 null，从而终止当前线程完成线程回收。 默认情况下，线程池只会回收非核心线程，如果希望核心线程也要回收，可以 设置 allowCoreThreadTimeOut 这个属性为 true，一般情况下我们不会去回收核 心线程。

因为线程池本身就是实现线程的复用，而且这些核心线程在没有任务要处理的时 候是处于阻塞状态并没有占用 CPU 资源