import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,f as t,b as e,d as o,a as l,o as c}from"./app-BeeusqHN.js";const a="/assets/1-DJp0x-LN.png",s={},d=e("p",null,[o("NiFi "),e("code",null,"Connection"),o("是在两个已连接的NiFi处理器组件之间临时保存FlowFiles的位置。每个包含排队的NiFi FlowFiles的"),e("code",null,"Connection"),o("在JVM堆中都会占一些空间。本文将对"),e("code",null,"Connection"),o("进行分析，探究NiFi如何管理在该"),e("code",null,"Connection"),o("中排队的FlowFiles和"),e("code",null,"Connection"),o("对堆和性能的影响。")],-1),r=l('<h2 id="正文" tabindex="-1"><a class="header-anchor" href="#正文"><span>正文</span></a></h2><p>首先看一下下面这张说明图</p><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>NiFi FlowFiles由FlowFile内容和FlowFile属性/元数据组成。 FlowFile内容永远不会保存在<code>Connection</code>中。<code>Connection</code>仅将FlowFile属性/元数据放置在堆中。</p><h3 id="connection-queue" tabindex="-1"><a class="header-anchor" href="#connection-queue"><span>&quot;Connection Queue&quot;</span></a></h3><p>&quot;Connection Queue&quot;保存了<code>Connection</code>中所有排队的FlowFiles的位置。要了解这些排队的FlowFile如何影响性能和堆使用情况，让我们首先关注上图底部的关于&quot;Connection Queue&quot;的剖析。</p><p><code>Connection</code>的整体大小由用户配置的<code>back Pressure Object Threshold</code>和<code>Back Pressure Data Size threshold</code>设置控制。</p><p><strong><code>Back Pressure Object Threshold</code> 和 <code>Back Pressure Data Size Threshold</code></strong></p><p>此处的<code>Back Pressure Object Threshold</code>默认设置为10000。</p><p><code>Back Pressure Data Size Threshold</code>默认为1 GB。</p><p>这两个设置都是软限制，这意味着可以超过它们。例如，假设上面的默认设置以及已经包含9500个FlowFiles的连接。由于连接尚未达到或超过对象阈值，因此允许运行该连接的处理器运行。如果此队列上游的处理器在执行时又生成了2000个FlowFiles，则<code>Connection</code>将增长到11500个排队的FlowFiles。然后，直到<code>Connection</code>再次下降到配置的阈值以下，才允许前一个处理器执行。(这就是背压机制)</p><p>数据大小阈值也是如此。数据大小基于与每个排队的FlowFile相关联的内容的累积大小。</p><p>现在，我们知道如何控制“connection queue”的整体大小，下面将其分解为几个部分：</p><ol><li>ACTIVE QUEUE：FlowFiles进入到一个<code>Connection</code>中将首先被放置在active队列中。 之后FlowFiles将继续被放入到此active队列，直到该队列达到全局配置的nifi交换阈值为止(swap threshold)。active队列中的所有FlowFiles都保存在堆内存中。从此<code>Connection</code>中使用Flowfile的处理器将始终从active队列中提取FlowFiles。每个连接的活动队列的大小由nifi.properties文件中的以下属性控制</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>nifi.queue.swap.threshold=20000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>交换阈值的增加会增加数据流中每个连接的潜在堆占用空间。</p><ol start="2"><li><p>SWAP QUEUE: 根据上述默认设置，一旦<code>Connection</code>达到20000个FlowFiles，进入连接的新FlowFiles将被放置在swap队列中。swap队列也保存在堆中，并且硬编码为最大10000个FlowFiles。如果活动队列中的空间已释放并且不存在交换文件，则交换队列中的FlowFiles将直接移到活动队列中。</p></li><li><p>SWAP FILES: 每次swap队列达到10000个FlowFiles时，会将包含这些FlowFiles的交换文件写入磁盘上。届时，新的FlowFiles将再次写入交换队列。NIFI可以创建许多交换文件(但设计上建议尽量减少)，上面图片的<code>Connection</code>包含80000个FlowFiles，堆中将有30000个FlowFiles和5个交换文件(active中有两万个，swap中有一万个，剩下的五万在交换文件里)。当活动队列释放10000个FlowFiles，因此最早的交换文件将移至活动队列，直到所有交换文件都消失。交换文件会产生磁盘IO读写，在整个数据流中产生大量交换文件，这一定会影响数据流的吞吐量性能。</p></li><li><p>IN-FLIGHT QUEUE: 与上面的3不同，运行中队列仅在使用此连接的处理器正在运行时才存在。消费处理器将仅从active队列中提取FlowFiles并将它们放置在运行队列中，直到成功处理完并且这些FlowFiles已从消费处理器提交到出站<code>Connection</code>为止。该运行中队列也保留在堆中。一些处理器一次处理一个FlowFile，另一些处理器处理批量的FlowFile，还有一些处理器可能处理传入连接队列中的每个FlowFile。在最后一种情况下，这可能意味着在处理这些FlowFiles时堆使用率很高。上面的使用MergeContent处理器的示例就可能是最后一种情况，假如MergeContent配置的结果为每次合并90000个FlowFile,那么这80000个FlowFile都会进入到运行队列中。</p></li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ol><li><p>通过限制连接队列的大小来控制堆的使用（如果可能的话）。 （当然，如果你打算合并40000个FlowFile，则传入连接中必须有40,000个Flowfile。但是，你可以串联使用两个mergeContent处理器，每个处理器合并较小的bundle，并获得相同的最终结果，而总堆使用量较少。）</p></li><li><p>使用默认的背压对象阈值设置，大多数连接上都不会生成交换文件（记住软限制），这将导致更好的吞吐量性能。</p></li><li><p>在大多数活动队列大小和性能的情况下，默认配置的交换阈值20000是一个很好的平衡。对于较小的流量，你可以将其推高，对于较大的流量，你可能需要将其设置为较低。只需了解这是为了性能而对堆使用情况进行的权衡。但是，如果你的堆用完了，性能将为零。</p></li></ol><h2 id="额外说一下队列的优先级排序器" tabindex="-1"><a class="header-anchor" href="#额外说一下队列的优先级排序器"><span>额外说一下队列的优先级排序器</span></a></h2><p>优先级排序器仅对active队列中当前的FlowFiles有效。由于此active队列位于JVM堆中，因此基于优先级的重新排序对性能的影响很小。每次新的FlowFile进入连接时，重新评估所有交换的FlowFiles都会影响吞吐量性能。请记住，当在连接上不定义优先级时，将始终获得最佳吞吐量。</p>',21);function F(p,h){return c(),n("div",null,[d,t(" more "),r])}const m=i(s,[["render",F],["__file","011-理解connection.html.vue"]]),g=JSON.parse('{"path":"/ApacheNIFI%E6%95%99%E7%A8%8B/011-%E7%90%86%E8%A7%A3connection.html","title":"深入理解Connection","lang":"zh-CN","frontmatter":{"title":"深入理解Connection","date":"2020-05-21T00:00:00.000Z","category":"ApacheNIFI教程","tag":"NIFI","order":11,"description":"NiFi Connection是在两个已连接的NiFi处理器组件之间临时保存FlowFiles的位置。每个包含排队的NiFi FlowFiles的Connection在JVM堆中都会占一些空间。本文将对Connection进行分析，探究NiFi如何管理在该Connection中排队的FlowFiles和Connection对堆和性能的影响。","head":[["meta",{"property":"og:url","content":"https://zhangchengk.github.io/ApacheNIFI%E6%95%99%E7%A8%8B/011-%E7%90%86%E8%A7%A3connection.html"}],["meta",{"property":"og:site_name","content":"Panda诚的博客"}],["meta",{"property":"og:title","content":"深入理解Connection"}],["meta",{"property":"og:description","content":"NiFi Connection是在两个已连接的NiFi处理器组件之间临时保存FlowFiles的位置。每个包含排队的NiFi FlowFiles的Connection在JVM堆中都会占一些空间。本文将对Connection进行分析，探究NiFi如何管理在该Connection中排队的FlowFiles和Connection对堆和性能的影响。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-27T13:31:00.000Z"}],["meta",{"property":"article:author","content":"Panda诚"}],["meta",{"property":"article:tag","content":"NIFI"}],["meta",{"property":"article:published_time","content":"2020-05-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-27T13:31:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"深入理解Connection\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-05-21T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-27T13:31:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Panda诚\\",\\"url\\":\\"https://zhangchengk.github.io/about/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"正文","slug":"正文","link":"#正文","children":[{"level":3,"title":"\\"Connection Queue\\"","slug":"connection-queue","link":"#connection-queue","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"额外说一下队列的优先级排序器","slug":"额外说一下队列的优先级排序器","link":"#额外说一下队列的优先级排序器","children":[]}],"git":{"createdTime":1719488402000,"updatedTime":1719495060000,"contributors":[{"name":"zhangcheng","email":"zhangchengk@yonyou.com","commits":2}]},"readingTime":{"minutes":5.03,"words":1508},"filePathRelative":"ApacheNIFI教程/011-理解connection.md","localizedDate":"2020年5月21日","excerpt":"<p>NiFi <code>Connection</code>是在两个已连接的NiFi处理器组件之间临时保存FlowFiles的位置。每个包含排队的NiFi FlowFiles的<code>Connection</code>在JVM堆中都会占一些空间。本文将对<code>Connection</code>进行分析，探究NiFi如何管理在该<code>Connection</code>中排队的FlowFiles和<code>Connection</code>对堆和性能的影响。</p>\\n","autoDesc":true}');export{m as comp,g as data};
