import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as n,a}from"./app-yELfxIoD.js";const e="/assets/1-C5EcWtNZ.png",t="/assets/2-DhXVHx4L.png",l="/assets/3-VGeqhtDP.png",p="/assets/4-DAM7jiNR.png",r="/assets/5-C2krh9QB.png",h="/assets/6-BAErqEQC.png",d="/assets/7-D56hZKli.png",o="/assets/8-BpXWu--1.png",c="/assets/9-CYaAD0h2.png",k={},u=a('<p>我们都知道NIFI设计了一套自己的表达式语言，在设计流程的时候表达式语言给我们提供了很大的灵活性，在官方文档中对表达式语言都有很详细的说明和示范，但有的时候我们期望增加一套特定情境，适合我们自己特殊的流程的表达式函数，本文主要介绍一个增加自定义NIFI表达式函数的demo。</p><h2 id="场景假设" tabindex="-1"><a class="header-anchor" href="#场景假设"><span>场景假设</span></a></h2><p>我们在属性中有一些中文，在流程里需要把这些值转bytes最后存储起来，那我们知道在Java中，String的getBytes()方法是得到一个操作系统默认的编码格式的字节数组。这个表示在不同OS下，返回的东西不一样！ String.getBytes(String decode)方法会根据指定的decode编码返回某字符串在该编码下的byte数组表示，那么我们就包装一个getBytes的函数</p><figure><img src="'+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="nifi开发" tabindex="-1"><a class="header-anchor" href="#nifi开发"><span>NIFI开发</span></a></h2><p>在nifi-expression-language子项目中进行自定义函数开发，在这个子项目中有个readme文件，里面较为详细的阐述了自定义开发表达式语言的流程和方法，在这里我直接复制一下</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>This document is intended to provide a walk-through of what is necessary</span></span>
<span class="line"><span>in order to add a new function to the Expression Language. Doing so requires</span></span>
<span class="line"><span>a handful of steps, so we will outline each of those steps here, in the order</span></span>
<span class="line"><span>that they must be done. While this documentation is fairly verbose, it is often</span></span>
<span class="line"><span>the case that reading the documentation takes longer than performing the tasks</span></span>
<span class="line"><span>outlined by the documentation.</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) In order to make the nifi-expression-language Maven module compile in your IDE, you may need to add the ANTLR-generated sources to your IDE&#39;s classpath.</span></span>
<span class="line"><span>   This can be done using Eclipse, as follows:</span></span>
<span class="line"><span>    - Right-click on the nifi-expression-language project</span></span>
<span class="line"><span>    - Go to &quot;Properties&quot; on the context menu</span></span>
<span class="line"><span>    - Go to the &quot;Java Build Path&quot; item in the left tree and choose the &quot;Source&quot; tab.</span></span>
<span class="line"><span>    - Click &quot;Add Folder...&quot;</span></span>
<span class="line"><span>    - Add the target/generated-sources/antlr3 folder. If this folder does not exist, first build the project from Maven and then</span></span>
<span class="line"><span>      right-click on the nifi-expression-language project in Eclipse and click Refresh.</span></span>
<span class="line"><span>    - Click OK to close all dialogs.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>2) Add the method name to the Tokens for the Lexer</span></span>
<span class="line"><span>	- Open the src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionLexer.g file</span></span>
<span class="line"><span>	- Add the function name to the list of tokens in this file. These functions are grouped by the number of arguments</span></span>
<span class="line"><span>	  that they take. This grouping mechanism could probably be made better, perhaps grouping by the type of function</span></span>
<span class="line"><span>	  provided. However, for now, it is best to keep some sort of structure, at least. If the function has optional</span></span>
<span class="line"><span>	  arguments, the function should be grouped by the maximum number of arguments that it takes (for example, the</span></span>
<span class="line"><span>	  substring function can take 1 or 2 arguments, so it is grouped with the &#39;2 argument functions&#39;).</span></span>
<span class="line"><span>	  The syntax to use is:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	  &lt;Token Name&gt; : &#39;&lt;function name&gt;&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	  The Token Name should be all-caps and words should be separated by underscores. The Token Name is what will be used to</span></span>
<span class="line"><span>	  identify the token when ANTLR parses an Expression. The function name should use camel case starting with a lower-case</span></span>
<span class="line"><span>	  letter. This is the name of the function as it will be referenced in the Expression Language.</span></span>
<span class="line"><span>	- Save the AttributeExpressionLexer.g file</span></span>
<span class="line"><span></span></span>
<span class="line"><span>3) Add the method to the grammar</span></span>
<span class="line"><span>	- Open the src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionParser.g file</span></span>
<span class="line"><span>	- Starting around line 75, the functions are defined, grouped by the type of value returned. We can add the new function</span></span>
<span class="line"><span>	  into the grammar here. Please see the ANTLR documentation for syntax on the grammar used. Note that this is ANTLR 3, NOT ANTLR 4.</span></span>
<span class="line"><span>	  The idea here is to spell out the syntax that should be used for the function. So generally, we do this by specifying the function name,</span></span>
<span class="line"><span>	  &quot;LPAREN!&quot; (which indicates a left parenthesis and the ! indicates that we do not want this passed to us when obtaining the parsed tokens),</span></span>
<span class="line"><span>	  and then a list of arguments that are separated by &quot;COMMA!&quot; (again, indicating a comma character and that we do not want the token passed</span></span>
<span class="line"><span>	  to us when we are looking at parsed tokens). We then end with the matching &quot;RPAREN!&quot;.</span></span>
<span class="line"><span>	- Save this file.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>4) Rebuild via Maven</span></span>
<span class="line"><span>	- In order to make sure that we now can reference the tokens that are generated for our new function, we need to rebuild via Maven.</span></span>
<span class="line"><span>	  We can do this by building just the nifi-expression-language project, rather than rebuilding the entire NiFi code base.</span></span>
<span class="line"><span>	- If necessary, right-click on the nifi-expression-language project in your IDE and refresh / update project from new Maven build.</span></span>
<span class="line"><span>	  This is generally necessary when using Eclipse.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>5) Add the logic for the function</span></span>
<span class="line"><span>	- In the src/main/java/org/apache/nifi/attribute/expression/language/evaluation/function package directory, we will need to create a new</span></span>
<span class="line"><span>	  class that is capable of implementing the logic of the new function. Create a class using the standard naming convention of</span></span>
<span class="line"><span>	  &lt;function name&gt;Evaluator and extends the appropriate abstract evaluator. If the function will return a String, the evaluator should extend</span></span>
<span class="line"><span>	  StringEvaluator. If the function will return a boolean, the evaluator should extend BooleanEvaluator. There are also evaluators for Date</span></span>
<span class="line"><span>	  and Number return types.</span></span>
<span class="line"><span>	- Generally the constructor for the evaluator will take an Evaluator for the &quot;Subject&quot; and an Evaluator for each argument. The subject is the</span></span>
<span class="line"><span>	  value that the function will be evaluated against. The substring function, for instance, takes a subject of type String. Thinking in terms of</span></span>
<span class="line"><span>	  Java, the &quot;subject&quot; is the object on which the function is being called. It is important to take Evaluator objects and not just a String,</span></span>
<span class="line"><span>	  for instance, as we have to ensure that we determine that actual values to use dynamically at runtime.</span></span>
<span class="line"><span>	- Implement the functionality as appropriate by implementing the abstract methods provided by the abstract Evaluator that is being extended by</span></span>
<span class="line"><span>	  your newly created Evaluator.</span></span>
<span class="line"><span>	- The Evaluator need not be thread-safe. The existing Evaluators are numerous and provide great examples for understanding the API.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>6) Add the logic to the query parser</span></span>
<span class="line"><span>	- Generally, when using ANTLR, the preferred method to parse the input is to use a Tree Walker. However, this is far less intuitive for many</span></span>
<span class="line"><span>	  Java developers (including those of us who wrote the Expression Language originally). As a result, we instead use ANTLR to tokenize and parse the</span></span>
<span class="line"><span>	  input and then obtain an Abstract Syntax Tree and process this &quot;manually&quot; in Java code. This occurs in the Query class.</span></span>
<span class="line"><span>	- We can add the function into our parsing logic by updating the #buildFunctionEvaluator method of the org.apache.nifi.attribute.expression.compile.ExpressionCompiler class.</span></span>
<span class="line"><span>	  A static import will likely need to be added to the Query class in order to reference the new token. The token can then be added to the existing</span></span>
<span class="line"><span>	  &#39;case&#39; statement, which will return a new instance of the Evaluator that was just added.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>7) Add Unit Tests!</span></span>
<span class="line"><span>	- Unit tests are critical for the Expression Language. These expressions can be used throughout the entire application and it is important that each function</span></span>
<span class="line"><span>	  perform its task properly. Otherwise, incorrect routing decisions could be made, or data could become corrupted as a result.</span></span>
<span class="line"><span>	- Each function should have its battery of unit tests added to the TestQuery class. This class includes a convenience method named #verifyEquals that is</span></span>
<span class="line"><span>	  used to ensure that the Expression returns the same value, regardless of how it is compiled and evaluated.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>8) Add Documentation!</span></span>
<span class="line"><span>	- The documentation for each function is provided in the nifi-docs module, under src/main/asciidoc/expression-language-guide.adoc.</span></span>
<span class="line"><span>	  The format of the document is crucial to maintain, as this document is not only rendered as HTML in the NiFi Documentation page, but the</span></span>
<span class="line"><span>	  CSS classes that are used in the rendered docs are also made use of by the NiFi UI. When a user is entering an Expression Language expression and</span></span>
<span class="line"><span>	  presses Ctrl+Space, the UI provides auto-completion information as well as inline documentation for each function. This information is pulled</span></span>
<span class="line"><span>	  directly from the HTML that is generated from this expression-language-guide file.</span></span>
<span class="line"><span>	- Rebuild NiFi and run the application. Add an UpdateAttribute Processor to the graph and add a new property. For the value, type the Expression Language</span></span>
<span class="line"><span>	  opening tokens \${ and then press Ctrl+Space to ensure that the function and its documentation is presented as expected. Most functions that are added</span></span>
<span class="line"><span>	  will require a Subject. In order to see the function, then, you will need to provide a subject, such as typing &quot;\${myVariable:&quot; (without the quotes)</span></span>
<span class="line"><span>	  and then press Ctrl+Space. This step is important, as it is quite easy to make a mistake when creating the documentation using a free-form text editor,</span></span>
<span class="line"><span>	  and this will ensure that users receive a very consistent and quality experience when using the new function.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我简单介绍一下我们设计的getBytes是怎么实现的</p><h3 id="第一步-编辑antlr配置文件" tabindex="-1"><a class="header-anchor" href="#第一步-编辑antlr配置文件"><span>第一步 编辑antlr配置文件</span></a></h3><p>(antlr是个什么自行查询资料，也不用想太多，照着上面的流程就能自己实现自定义表达式语言函数了)</p><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="第二步-新建evaluator" tabindex="-1"><a class="header-anchor" href="#第二步-新建evaluator"><span>第二步 新建Evaluator</span></a></h3><p>具体该继承哪一个Evaluator，看上面的说明和源码，我这里期望getBytes返回的是byte数组的字符串</p><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> GetBytesEvaluator</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> StringEvaluator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Evaluator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> subject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Evaluator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> charSetStr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> GetBytesEvaluator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Evaluator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">subject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Evaluator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">charSetStr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">subject</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> subject;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">charSetStr</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> charSetStr;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> QueryResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> evaluate</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> EvaluationContext</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> evaluationContext</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        final</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> subjectValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> subject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">evaluate</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(evaluationContext).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getValue</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> charSetStrValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> charSetStr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">evaluate</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(evaluationContext).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getValue</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">StringUtils</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">isBlank</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(charSetStrValue)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            charSetStrValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> StandardCharsets</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">UTF_8</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> StringQueryResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> subjectValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Arrays</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">subjectValue</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getBytes</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(charSetStrValue)));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">UnsupportedEncodingException</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> StringQueryResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(subjectValue);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Evaluator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getSubjectEvaluator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="第三步-用maven重新编译一下" tabindex="-1"><a class="header-anchor" href="#第三步-用maven重新编译一下"><span>第三步 用maven重新编译一下</span></a></h3><p>其实主要是把我们修改的antlr文件编译成新的类</p><h3 id="第四步-注册getbytes函数" tabindex="-1"><a class="header-anchor" href="#第四步-注册getbytes函数"><span>第四步 注册getBytes函数</span></a></h3><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="第五步-重新编译nifi" tabindex="-1"><a class="header-anchor" href="#第五步-重新编译nifi"><span>第五步 重新编译NIFI</span></a></h3><p>也可以单独编译nifi-expression-language和引用nifi-expression-language的其他子项目，我觉得挨个找有些费劲，就重新编译NIFI了。</p><h3 id="效果展示" tabindex="-1"><a class="header-anchor" href="#效果展示"><span>效果展示</span></a></h3><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',27),g=[u];function v(m,y){return n(),i("div",null,g)}const f=s(k,[["render",v],["__file","005-自定义ExpressionLanguage.html.vue"]]),E=JSON.parse('{"path":"/ApacheNIFI%E5%BC%80%E5%8F%91/005-%E8%87%AA%E5%AE%9A%E4%B9%89ExpressionLanguage.html","title":"自定义ExpressionLanguage","lang":"zh-CN","frontmatter":{"title":"自定义ExpressionLanguage","date":"2020-05-21T00:00:00.000Z","category":"ApacheNIFI开发","tag":"NIFI","order":5,"description":"我们都知道NIFI设计了一套自己的表达式语言，在设计流程的时候表达式语言给我们提供了很大的灵活性，在官方文档中对表达式语言都有很详细的说明和示范，但有的时候我们期望增加一套特定情境，适合我们自己特殊的流程的表达式函数，本文主要介绍一个增加自定义NIFI表达式函数的demo。 场景假设 我们在属性中有一些中文，在流程里需要把这些值转bytes最后存储起来...","head":[["meta",{"property":"og:url","content":"https://zhangchengk.github.io/ApacheNIFI%E5%BC%80%E5%8F%91/005-%E8%87%AA%E5%AE%9A%E4%B9%89ExpressionLanguage.html"}],["meta",{"property":"og:site_name","content":"Panda诚的博客"}],["meta",{"property":"og:title","content":"自定义ExpressionLanguage"}],["meta",{"property":"og:description","content":"我们都知道NIFI设计了一套自己的表达式语言，在设计流程的时候表达式语言给我们提供了很大的灵活性，在官方文档中对表达式语言都有很详细的说明和示范，但有的时候我们期望增加一套特定情境，适合我们自己特殊的流程的表达式函数，本文主要介绍一个增加自定义NIFI表达式函数的demo。 场景假设 我们在属性中有一些中文，在流程里需要把这些值转bytes最后存储起来..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-27T13:31:00.000Z"}],["meta",{"property":"article:author","content":"Panda诚"}],["meta",{"property":"article:tag","content":"NIFI"}],["meta",{"property":"article:published_time","content":"2020-05-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-27T13:31:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"自定义ExpressionLanguage\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-05-21T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-27T13:31:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Panda诚\\",\\"url\\":\\"https://zhangchengk.github.io/about/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"场景假设","slug":"场景假设","link":"#场景假设","children":[]},{"level":2,"title":"NIFI开发","slug":"nifi开发","link":"#nifi开发","children":[{"level":3,"title":"第一步 编辑antlr配置文件","slug":"第一步-编辑antlr配置文件","link":"#第一步-编辑antlr配置文件","children":[]},{"level":3,"title":"第二步 新建Evaluator","slug":"第二步-新建evaluator","link":"#第二步-新建evaluator","children":[]},{"level":3,"title":"第三步 用maven重新编译一下","slug":"第三步-用maven重新编译一下","link":"#第三步-用maven重新编译一下","children":[]},{"level":3,"title":"第四步 注册getBytes函数","slug":"第四步-注册getbytes函数","link":"#第四步-注册getbytes函数","children":[]},{"level":3,"title":"第五步 重新编译NIFI","slug":"第五步-重新编译nifi","link":"#第五步-重新编译nifi","children":[]},{"level":3,"title":"效果展示","slug":"效果展示","link":"#效果展示","children":[]}]}],"git":{"createdTime":1719488402000,"updatedTime":1719495060000,"contributors":[{"name":"zhangcheng","email":"zhangchengk@yonyou.com","commits":2}]},"readingTime":{"minutes":6.3,"words":1890},"filePathRelative":"ApacheNIFI开发/005-自定义ExpressionLanguage.md","localizedDate":"2020年5月21日","excerpt":"<p>我们都知道NIFI设计了一套自己的表达式语言，在设计流程的时候表达式语言给我们提供了很大的灵活性，在官方文档中对表达式语言都有很详细的说明和示范，但有的时候我们期望增加一套特定情境，适合我们自己特殊的流程的表达式函数，本文主要介绍一个增加自定义NIFI表达式函数的demo。</p>\\n<h2>场景假设</h2>\\n<p>我们在属性中有一些中文，在流程里需要把这些值转bytes最后存储起来，那我们知道在Java中，String的getBytes()方法是得到一个操作系统默认的编码格式的字节数组。这个表示在不同OS下，返回的东西不一样！ String.getBytes(String decode)方法会根据指定的decode编码返回某字符串在该编码下的byte数组表示，那么我们就包装一个getBytes的函数</p>","autoDesc":true}');export{f as comp,E as data};
